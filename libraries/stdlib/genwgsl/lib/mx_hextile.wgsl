struct HextileData {
    coords: array<vec2<f32>, 3>,
    weights: vec3<f32>,
    rotations: vec3<f32>,
    ddx: array<vec2<f32>, 3>,
    ddy: array<vec2<f32>, 3>,
}

fn mx_hextile_hash(p: vec2<f32>) -> vec2<f32> {
    var p_1: vec2<f32>;
    var p3_: vec3<f32>;

    p_1 = p;
    let _e2 = p_1;
    let _e4 = p_1;
    let _e6 = p_1;
    p3_ = fract((vec3<f32>(_e2.x, _e4.y, _e6.x) * vec3<f32>(0.1031f, 0.103f, 0.0973f)));
    let _e16 = p3_;
    let _e17 = p3_;
    let _e18 = p3_;
    let _e20 = p3_;
    let _e22 = p3_;
    p3_ = (_e16 + vec3(dot(_e17, (vec3<f32>(_e18.y, _e20.z, _e22.x) + vec3(33.33f)))));
    let _e31 = p3_;
    let _e33 = p3_;
    let _e36 = p3_;
    let _e38 = p3_;
    let _e42 = p3_;
    let _e44 = p3_;
    return fract(((vec2<f32>(_e31.x, _e33.x) + vec2<f32>(_e36.y, _e38.z)) * vec2<f32>(_e42.z, _e44.y)));
}

fn mx_schlick_gain(x_6: f32, r: f32) -> f32 {
    var x_7: f32;
    var r_1: f32;
    var rr: f32;
    var a: f32;
    var local: f32;

    x_7 = x_6;
    r_1 = r;
    let _e4 = r_1;
    rr = clamp(_e4, 0.001f, 0.999f);
    let _e10 = rr;
    let _e16 = x_7;
    a = (((1f / _e10) - 2f) * (1f - (2f * _e16)));
    let _e21 = x_7;
    if (_e21 < 0.5f) {
        let _e24 = x_7;
        let _e25 = a;
        local = (_e24 / (_e25 + 1f));
    } else {
        let _e29 = a;
        let _e30 = x_7;
        let _e32 = a;
        local = ((_e29 - _e30) / (_e32 - 1f));
    }
    let _e37 = local;
    return _e37;
}

fn mx_hextile_compute_blend_weights(luminance_weights: vec3<f32>, tile_weights: vec3<f32>, falloff: f32) -> vec3<f32> {
    var luminance_weights_1: vec3<f32>;
    var tile_weights_1: vec3<f32>;
    var falloff_1: f32;
    var w: vec3<f32>;

    luminance_weights_1 = luminance_weights;
    tile_weights_1 = tile_weights;
    falloff_1 = falloff;
    let _e6 = luminance_weights_1;
    let _e7 = tile_weights_1;
    w = (_e6 * pow(_e7, vec3(7f)));
    let _e13 = w;
    let _e14 = w;
    let _e16 = w;
    let _e19 = w;
    w = (_e13 / vec3(((_e14.x + _e16.y) + _e19.z)));
    let _e24 = falloff_1;
    if (_e24 != 0.5f) {
        {
            let _e28 = w;
            let _e30 = falloff_1;
            let _e31 = mx_schlick_gain(_e28.x, _e30);
            w.x = _e31;
            let _e33 = w;
            let _e35 = falloff_1;
            let _e36 = mx_schlick_gain(_e33.y, _e35);
            w.y = _e36;
            let _e38 = w;
            let _e40 = falloff_1;
            let _e41 = mx_schlick_gain(_e38.z, _e40);
            w.z = _e41;
            let _e42 = w;
            let _e43 = w;
            let _e45 = w;
            let _e48 = w;
            w = (_e42 / vec3(((_e43.x + _e45.y) + _e48.z)));
        }
    }
    let _e53 = w;
    return _e53;
}

fn mx_hextile_coord(coord: vec2<f32>, rotation: f32, rotation_range: vec2<f32>, scale: f32, scale_range: vec2<f32>, offset: f32, offset_range: vec2<f32>) -> HextileData {
    var coord_1: vec2<f32>;
    var rotation_1: f32;
    var rotation_range_1: vec2<f32>;
    var scale_1: f32;
    var scale_range_1: vec2<f32>;
    var offset_1: f32;
    var offset_range_1: vec2<f32>;
    var sqrt3_2_: f32 = 3.4641016f;
    var st: vec2<f32>;
    var to_skewed: mat2x2<f32> = mat2x2<f32>(vec2<f32>(1f, 0f), vec2<f32>(-0.57735026f, 1.1547005f));
    var st_skewed: vec2<f32>;
    var st_frac: vec2<f32>;
    var temp: vec3<f32>;
    var s: f32;
    var s2_: f32;
    var w1_: f32;
    var w2_: f32;
    var w3_: f32;
    var base_id: vec2<i32>;
    var si: i32;
    var id1_: vec2<i32>;
    var id2_: vec2<i32>;
    var id3_: vec2<i32>;
    var inv_skewed: mat2x2<f32> = mat2x2<f32>(vec2<f32>(1f, 0f), vec2<f32>(0.5f, 0.86602545f));
    var ctr1_: vec2<f32>;
    var ctr2_: vec2<f32>;
    var ctr3_: vec2<f32>;
    var seed_offset: vec2<f32> = vec2(0.12345f);
    var rand1_: vec2<f32>;
    var rand2_: vec2<f32>;
    var rand3_: vec2<f32>;
    var rr_1: vec2<f32>;
    var rand_x: vec3<f32>;
    var rotations: vec3<f32>;
    var sin_r: vec3<f32>;
    var cos_r: vec3<f32>;
    var rm1_: mat2x2<f32>;
    var rm2_: mat2x2<f32>;
    var rm3_: mat2x2<f32>;
    var rand_y: vec3<f32>;
    var scales: vec3<f32>;
    var scale1_: vec2<f32>;
    var scale2_: vec2<f32>;
    var scale3_: vec2<f32>;
    var offset1_: vec2<f32>;
    var offset2_: vec2<f32>;
    var offset3_: vec2<f32>;
    var tile_data: HextileData;
    var ddx: vec2<f32>;
    var ddy: vec2<f32>;

    coord_1 = coord;
    rotation_1 = rotation;
    rotation_range_1 = rotation_range;
    scale_1 = scale;
    scale_range_1 = scale_range;
    offset_1 = offset;
    offset_range_1 = offset_range;
    let _e19 = coord_1;
    let _e20 = sqrt3_2_;
    st = (_e19 * _e20);
    let _e32 = to_skewed;
    let _e33 = st;
    let _e34 = mx_matrix_mul_3(_e32, _e33);
    st_skewed = _e34;
    let _e36 = st_skewed;
    st_frac = fract(_e36);
    let _e39 = st_frac;
    let _e41 = st_frac;
    temp = vec3<f32>(_e39.x, _e41.y, 0f);
    let _e48 = temp;
    let _e51 = temp;
    temp.z = ((1f - _e48.x) - _e51.y);
    let _e55 = temp;
    s = step(0f, -(_e55.z));
    let _e61 = s;
    s2_ = ((2f * _e61) - 1f);
    let _e66 = temp;
    let _e69 = s2_;
    w1_ = (-(_e66.z) * _e69);
    let _e72 = s;
    let _e73 = temp;
    let _e75 = s2_;
    w2_ = (_e72 - (_e73.y * _e75));
    let _e79 = s;
    let _e80 = temp;
    let _e82 = s2_;
    w3_ = (_e79 - (_e80.x * _e82));
    let _e86 = st_skewed;
    base_id = vec2<i32>(floor(_e86));
    let _e90 = s;
    si = i32(_e90);
    let _e93 = base_id;
    let _e94 = si;
    let _e95 = si;
    id1_ = (_e93 + vec2<i32>(_e94, _e95));
    let _e99 = base_id;
    let _e100 = si;
    let _e102 = si;
    id2_ = (_e99 + vec2<i32>(_e100, (1i - _e102)));
    let _e107 = base_id;
    let _e109 = si;
    let _e111 = si;
    id3_ = (_e107 + vec2<i32>((1i - _e109), _e111));
    let _e125 = inv_skewed;
    let _e126 = id1_;
    let _e128 = sqrt3_2_;
    let _e131 = mx_matrix_mul_3(_e125, (vec2<f32>(_e126) / vec2(_e128)));
    ctr1_ = _e131;
    let _e133 = inv_skewed;
    let _e134 = id2_;
    let _e136 = sqrt3_2_;
    let _e139 = mx_matrix_mul_3(_e133, (vec2<f32>(_e134) / vec2(_e136)));
    ctr2_ = _e139;
    let _e141 = inv_skewed;
    let _e142 = id3_;
    let _e144 = sqrt3_2_;
    let _e147 = mx_matrix_mul_3(_e141, (vec2<f32>(_e142) / vec2(_e144)));
    ctr3_ = _e147;
    let _e152 = id1_;
    let _e154 = seed_offset;
    let _e156 = mx_hextile_hash((vec2<f32>(_e152) + _e154));
    rand1_ = _e156;
    let _e158 = id2_;
    let _e160 = seed_offset;
    let _e162 = mx_hextile_hash((vec2<f32>(_e158) + _e160));
    rand2_ = _e162;
    let _e164 = id3_;
    let _e166 = seed_offset;
    let _e168 = mx_hextile_hash((vec2<f32>(_e164) + _e166));
    rand3_ = _e168;
    let _e170 = rotation_range_1;
    rr_1 = radians(_e170);
    let _e173 = rand1_;
    let _e175 = rand2_;
    let _e177 = rand3_;
    rand_x = vec3<f32>(_e173.x, _e175.x, _e177.x);
    let _e181 = rr_1;
    let _e184 = rr_1;
    let _e187 = rand_x;
    let _e188 = rotation_1;
    rotations = mix(vec3(_e181.x), vec3(_e184.y), (_e187 * _e188));
    let _e192 = rotations;
    sin_r = sin(_e192);
    let _e195 = rotations;
    cos_r = cos(_e195);
    let _e198 = cos_r;
    let _e200 = sin_r;
    let _e203 = sin_r;
    let _e205 = cos_r;
    rm1_ = mat2x2<f32>(vec2<f32>(_e198.x, -(_e200.x)), vec2<f32>(_e203.x, _e205.x));
    let _e211 = cos_r;
    let _e213 = sin_r;
    let _e216 = sin_r;
    let _e218 = cos_r;
    rm2_ = mat2x2<f32>(vec2<f32>(_e211.y, -(_e213.y)), vec2<f32>(_e216.y, _e218.y));
    let _e224 = cos_r;
    let _e226 = sin_r;
    let _e229 = sin_r;
    let _e231 = cos_r;
    rm3_ = mat2x2<f32>(vec2<f32>(_e224.z, -(_e226.z)), vec2<f32>(_e229.z, _e231.z));
    let _e237 = rand1_;
    let _e239 = rand2_;
    let _e241 = rand3_;
    rand_y = vec3<f32>(_e237.y, _e239.y, _e241.y);
    let _e247 = scale_range_1;
    let _e250 = scale_range_1;
    let _e253 = rand_y;
    let _e255 = scale_1;
    scales = mix(vec3(1f), mix(vec3(_e247.x), vec3(_e250.y), _e253), vec3(_e255));
    let _e259 = scales;
    scale1_ = vec2(_e259.x);
    let _e263 = scales;
    scale2_ = vec2(_e263.y);
    let _e267 = scales;
    scale3_ = vec2(_e267.z);
    let _e271 = offset_range_1;
    let _e274 = offset_range_1;
    let _e277 = rand1_;
    let _e278 = offset_1;
    offset1_ = mix(vec2(_e271.x), vec2(_e274.y), (_e277 * _e278));
    let _e282 = offset_range_1;
    let _e285 = offset_range_1;
    let _e288 = rand2_;
    let _e289 = offset_1;
    offset2_ = mix(vec2(_e282.x), vec2(_e285.y), (_e288 * _e289));
    let _e293 = offset_range_1;
    let _e296 = offset_range_1;
    let _e299 = rand3_;
    let _e300 = offset_1;
    offset3_ = mix(vec2(_e293.x), vec2(_e296.y), (_e299 * _e300));
    let _e306 = w1_;
    let _e307 = w2_;
    let _e308 = w3_;
    tile_data.weights = vec3<f32>(_e306, _e307, _e308);
    let _e311 = rotations;
    tile_data.rotations = _e311;
    let _e315 = coord_1;
    let _e316 = ctr1_;
    let _e318 = rm1_;
    let _e319 = mx_matrix_mul((_e315 - _e316), _e318);
    let _e320 = scale1_;
    let _e322 = ctr1_;
    let _e324 = offset1_;
    tile_data.coords[0i] = (((_e319 / _e320) + _e322) + _e324);
    let _e329 = coord_1;
    let _e330 = ctr2_;
    let _e332 = rm2_;
    let _e333 = mx_matrix_mul((_e329 - _e330), _e332);
    let _e334 = scale2_;
    let _e336 = ctr2_;
    let _e338 = offset2_;
    tile_data.coords[1i] = (((_e333 / _e334) + _e336) + _e338);
    let _e343 = coord_1;
    let _e344 = ctr3_;
    let _e346 = rm3_;
    let _e347 = mx_matrix_mul((_e343 - _e344), _e346);
    let _e348 = scale3_;
    let _e350 = ctr3_;
    let _e352 = offset3_;
    tile_data.coords[2i] = (((_e347 / _e348) + _e350) + _e352);
    let _e354 = coord_1;
    let _e355 = dpdx(_e354);
    ddx = _e355;
    let _e357 = coord_1;
    let _e358 = dpdy(_e357);
    ddy = _e358;
    let _e363 = ddx;
    let _e364 = rm1_;
    let _e365 = mx_matrix_mul(_e363, _e364);
    let _e366 = scale1_;
    tile_data.ddx[0i] = (_e365 / _e366);
    let _e371 = ddx;
    let _e372 = rm2_;
    let _e373 = mx_matrix_mul(_e371, _e372);
    let _e374 = scale2_;
    tile_data.ddx[1i] = (_e373 / _e374);
    let _e379 = ddx;
    let _e380 = rm3_;
    let _e381 = mx_matrix_mul(_e379, _e380);
    let _e382 = scale3_;
    tile_data.ddx[2i] = (_e381 / _e382);
    let _e387 = ddy;
    let _e388 = rm1_;
    let _e389 = mx_matrix_mul(_e387, _e388);
    let _e390 = scale1_;
    tile_data.ddy[0i] = (_e389 / _e390);
    let _e395 = ddy;
    let _e396 = rm2_;
    let _e397 = mx_matrix_mul(_e395, _e396);
    let _e398 = scale2_;
    tile_data.ddy[1i] = (_e397 / _e398);
    let _e403 = ddy;
    let _e404 = rm3_;
    let _e405 = mx_matrix_mul(_e403, _e404);
    let _e406 = scale3_;
    tile_data.ddy[2i] = (_e405 / _e406);
    let _e408 = tile_data;
    return _e408;
}
